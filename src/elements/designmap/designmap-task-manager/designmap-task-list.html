<link rel="import" href="/bower_components/polymer/polymer.html">
<link rel="import" href="../../plastic/plastic-custom-scroll.html">
<link rel="import" href="../designmap-ui/designmap-hidden-panel.html">
<link rel="import" href="./designmap-assignee.html">
<link rel="import" href="../../../styles/tooltip-shared-styles.html">
<link rel="import" href="../../reworked/paper-checkbox/paper-checkbox.html">
<!-- Thrid party -->
<link rel="import" href="../../reworked/polymer-sortablejs/polymer-sortablejs.html">
<!-- Services -->
<link rel="import" href="./deaignmap-task-service.html">
<link rel="import" href="./designmap-task-notify-service.html">
<link rel="import" href="../designmap-tutorial/designmap-hint-service.html">
<link rel="import" href="../designmap-fs/designmap-fs-service.html">
<!-- Redux -->
<link rel="import" href="../../../redux/redux-store.html">
<link rel="import" href="../../../redux/actions/combine-actions.html">
<link rel="import" href="../../../redux/actions/files-actions.html">
<link rel="import" href="../../../redux/actions/user-actions.html">
<link rel="import" href="../../../redux/actions/tasks-actions.html">

<dom-module id="designmap-task-list">
    <template>
        <style include="tooltip-shared-styles">
            :host {
                flex: 1;
                position: relative;
                padding-right: 4px;
                background: var(--white-color);
                --plastic-custom-scroll-bar-mixin: {
                    margin-left: -8px;
                };
                --plastic-custom-scroll-bar-hover-mixin: {
                    margin-left: -10px;
                };
                --plastic-custom-scroll-bar-grabbed-mixin: {
                    margin-left: -10px;
                };

                --designmap-circle-button-circle-mixin: {
                    stroke-width: 1px !important;
                    stroke: var(--gray-saturated-color) !important;
                };

                --filter-color: var(--gray-saturated-color);
                --filter-all: var(--blue-darker-color);
                --filter-incomplete: var(--incomplete);
                --filter-inprogress: var(--inprogress);
                --filter-completed: var(--completed);
                --filter-expired: var(--expired);

                --designmap-hidden-panel: {
                    height: var(--header-height);
                    background: var(--blue-color);
                    z-index: 9999;
                };

                --designmap-circle-button-circle-mixin: {
                    stroke: #fff !important;
                    stroke-width: 1px;
                }

                /** CHECKBOX **/
                --paper-checkbox-unchecked-color: var(--gray-darkend-color);
                --paper-checkbox-checked-color: var(--blue-color);
                --paper-checkbox-mixin: {
                    border: 1px solid var(--gray-color-darked);
                    overflow: hidden;
                }
                --paper-checkbox-checkmark-mixin: {
                    border: 1px solid var(--gray-color-darked);
                    transform: rotate(55deg);
                    top: -1px;
                    width: 14px;
                    left: -6px;
                }
            }

            :host(.notask) {
                border-rigth: 1px solid #ccc;
            }

            *[hidden] {
                display: none !important;
            }

            /** FILTER **/
            .filters {
                height: 42px;
                width: 100%;
                display: flex;
                align-items: center;
                font-family: var(--font-family);
                font-weight: 300;
                font-size: 15px;
                color: var(--filter-color);
            }

            .filter-wrapper {
                display: block;
                padding-left: 20px;
            }

            .filters .filter {
                margin-left: 4px;
                height: 50px;
                width: 100%;
                display: flex;
                align-items: center;
                cursor: pointer;
            }

            .filters .filter iron-icon {
                width: 20px;
                height: 20px;
            }

            .filters .filter span {
                line-height: 0px;
                margin-left: 18px;
            }

            .desktop-filters {
                display: flex;
                @apply(--designmap-tasl-list-filters);
            }

            .desktop-filters .row {
                display: flex;
                margin-left: 15px;
                align-items: center;
            }

            .desktop-filters .row:first-child {
                display: flex;
                margin-left: 24px;
                @apply(--designmap-tasl-list-filters-first-child);
            }

            .desktop-filters .row span {
                margin-left: 10px !important;
            }

            .desktop-filters .row.selected {
                text-decoration: underline;
            }

            .mine-checkbox {
                margin-left: 13px;
            }

            /** DROP DOWN **/
            .filters #filterSelector {
                --designmap-dropdown-mixin: {
                    border: 1px solid var(--gray-lighty-color);
                    box-shadow: 0px 4px 8px -1px rgba(0, 0, 0, 0.15);
                    padding: 28px;
                    max-width: 200px;
                };
                --designmap-dropdown-triangle-mixin: {
                    left: 0px;
                    margin-left: 19px;
                };
                --designmap-dropdown-triangle-border-mixin: {
                    z-index: 9;
                    margin-left: 17px;
                    top: -12px;
                };
                --designmap-dropdown-triangle-border-color: var(--gray-lighty-color);
                --designmap-dropdown-background: var(--white-color);
                --designmap-dropdown-color: var(--filter-color);
            }

            #filterSelector .row iron-icon, .desktop-filters .row iron-icon {
                width: 20px;
                height: 20px;
            }

            #filterSelector .row, .desktop-filters .row {
                cursor: pointer;
            }

            #filterSelector .row span, .desktop-filters .row span {
                font-size: 15px;
                margin-left: 18px;
            }

            /** NOT FOUND **/
            .not-found-msg {
                font-family: var(--font-family);
                font-weight: 300;
                text-align: left;
                margin: 10px 49px;
                color: var(--filter-color);
                @apply(--designmap-task-list-not-found-mixin)
            }

            /** LIST **/
            .list {
                list-style: none;
                padding: 0;
                margin: 0;
                padding-left: 8px;
                @apply(--designmap-task-list-list-mixin);
            }

            .list li {
                height: 50px;
                font-family: var(--font-family);
                font-weight: 300;
                font-size: 20px;
                color: var(--filter-color);
                display: flex;
                align-items: center;
                transition: background .3s;
            }

            .list li:hover {
                /*background: #f7f7f7;*/
                cursor: pointer;
                transition: background .3s;
            }

            .list li .title {
                width: 100%;
                height: 100%;
                line-height: 50px;
                flex-grow: 1;
                overflow: hidden;
                text-overflow: ellipsis;
                text-align: left;
                @apply(--designmap-task-list-title-mixin);
            }

            .list li.completed .title {
                /*text-decoration: line-through;*/
            }

            .list li .status-button {
                min-width: 50px;
                min-height: 50px;
                height: 50px;
                @apply(--designmap-task-list-status-button-mixin);
            }

            .list li .status-button .status-icon {
                padding: 15px 16px;
            }

            .status-icon {
                --iron-icon-components-mixin: {
                    stroke: var(--filter-color) !important;
                };
            }

            .list li.expired .status-icon {
                --iron-icon-components-mixin: {
                    stroke: var(--filter-expired) !important;
                };
            }

            .list li.selected .status-icon {
                --iron-icon-components-mixin: {
                    stroke: var(--white-color) !important;
                };
            }

            /** Buttons **/

            .list li designmap-circle-button {
                --designmap-circle-button-circle-mixin: {
                    stroke-width: 1px !important;
                    stroke: var(--filter-color) !important;
                }
            }

            .list li.expired designmap-circle-button {
                --designmap-circle-button-circle-mixin: {
                    stroke: var(--filter-expired) !important;
                };
            }

            .list li.selected designmap-circle-button {
                --designmap-circle-button-circle-mixin: {
                    stroke-width: 1px !important;
                    stroke: var(--white-color) !important;
                };
            }

            .list li:nth-child(2n+1) {
                transition: background .3s;
            }

            .list li:nth-child(2n+1):hover {
                /*background: #e9e9e9;*/
                transition: background .3s;
            }

            /** SELECTED **/
            .list li.selected {
                color: var(--white-color);
            }

            .list li.selected .no-selected {
                display: none;
            }

            .list li .done {
                display: none;
                min-width: 20px;
                min-height: 20px;
                margin-right: 20px;
                border-radius: 50%;
                background: var(--white-color);
            }

            .list li.selected .done {
                display: block;
            }

            .done .mark {
                display: none;
            }

            .completed .done .mark {
                display: block;
                width: 20px;
                height: 20px;
                transform: rotate(45deg);
            }

            .checkmark_stem {
                position: absolute;
                width: 3px;
                height: 9px;
                background-color: var(--gray-darkend-color);
                left: 11px;
                top: 4px;
            }

            .checkmark_kick {
                position: absolute;
                width: 7px;
                height: 3px;
                background-color: var(--gray-darkend-color);
                left: 7px;
                top: 11px;
            }

            li.expired .title {
                color: var(--filter-expired);
            }

            /** Selected **/

            .list li.selected.in_progress {
                background: var(--filter-inprogress);
                transition: background .2s;
            }

            .list li.selected.incomplete {
                background: var(--filter-incomplete);
                transition: background .2s;
            }

            .list li.selected.completed {
                background: var(--filter-completed);
                transition: background .2s;
            }

            .list li.selected.expired {
                background: var(--filter-expired);
                transition: background .2s;
            }

            .list li.selected .title {
                color: var(--white-color);
            }

            /** ASSIGNEE **/
            li designmap-assignee {
                min-width: 50px;
                min-height: 50px;
                height: 50px;
                width: 50px;
            }

            li designmap-assignee {
                --designmap-assignee-assigned-mixin: {
                    background: #f4f4f4;
                    color: var(--filter-color);
                    margin: 0 auto !important;
                    margin-top: 3px !important;
                    width: 40px;
                    height: 40px;
                    line-height: 41px;
                };

            }

            li designmap-assignee {
                --designmap-circle-button-content-icon-mixin: {
                    width: 55%;
                    height: 55%;
                    padding: 16% 19% !important;
                }
            }

            /** SUBTASKS **/
            li .subtask {
                padding: 0 15px 0 5px;
                position: relative;
            }

            li .subtask iron-icon {
                width: 30px;
                height: 30px;
                margin-top: 4px;
            }

            .subtask-count {
                position: absolute;
                font-size: 12px;
                top: 15px;
                left: 21px;
                color: var(--filter-color);
            }

            .subtask-count.dec {
                left: 18px;
            }

            .list li.selector {
                background: var(--gray-lightenest-color);
            }

            .list li.expired .subtask-count {
                color: var(--filter-expired);
            }

            .list li.expired .subtask iron-icon {
                --iron-icon-components-mixin: {
                    stroke: var(--filter-expired) !important;
                };
            }

            .list li.selected .subtask-count {
                color: var(--white-color);
            }

            .list li.selected .subtask iron-icon {
                --iron-icon-components-mixin: {
                    stroke: var(--white-color) !important;
                };
            }

            /** MESSAGE **/
            .message {
                text-align: center;
                margin: 10px 0;
            }

            .expired_row {
                font-size: 14px;
                white-space: nowrap;
                padding: 0 10px;
                flex-grow: 1;
            }

            .list li.expired .expired_row {
                color: var(--filter-expired);
            }

            /** ADD TASK FIELD **/
            .add-task {
                width: 100%;
                height: 35px;
            }

            .add-task-wrapper {
                position: relative;
                padding: 0 57px;
                @apply(--designmap-task-list-add-task-wrapper-mixin);
            }

            /** INPUT **/
            .add-task-wrapper > input {
                font-family: var(--font-family);
                font-weight: 300;
                font-size: 22px;
                border: none;
                outline: none;
                margin-top: 10px;
                width: 100%;
                color: var(--gray-darkend-color);
                @apply(--designmap-task-list-add-input-mixin);
            }
            ::-webkit-input-placeholder { color:var(--gray-saturate-color); opacity: 1 !important; }
            input::-moz-placeholder { color:var(--gray-saturate-color) !important; opacity: 1 !important;}
            input:-moz-placeholder { color:var(--gray-saturate-color) !important; opacity: 1 !important;}

            :host([small-add-task]) .add-task-wrapper > input {
                font-size: 18px;
            }

            /** LINE **/
            .line {
                position: absolute;
                width: 4px;
                top: 0;
                height: 100%;
                left: calc(100% - 4px);
                background: var(--white-color);
                cursor: col-resize;
                transition: all .2s linear;
            }

            .line:hover,  .line.dragged {
                width: 6px;
                left: calc(100% - 6px);
                transition: all .2s linear;
            }

            .status-line {
                width: 1px;
                height: 100%;
                margin-right: 8px;
                background: var(--white-color);
            }

            .line.in_progress, .in_progress .status-line {
                background: var(--filter-inprogress);
                transition: background .2s;
            }

            .line.incomplete, .incomplete .status-line {
                background: var(--filter-incomplete);
                transition: background .2s;
            }

            .line.completed, .completed .status-line {
                background: var(--filter-completed);
                transition: background .2s;
            }

            .line.expired, .expired .status-line {
                background: var(--filter-expired);
                transition: background .2s;
            }

            /** SUB-LINE **/

            .hidden-lg {
                display: none;
            }
            /** Labels **/
            .label {
                color: var(--white-color);
                font-size: 12px;
                white-space: nowrap;
                min-width: 60px;
                overflow: hidden;
                text-overflow: ellipsis;
                padding: 5px 10px;
                text-align: center;
                margin-right: 10px;
            }

            /** WHITE SPACE **/
            .white-space {
                display: flex;
                width: 100%;
                height: 100%;
                align-items: center;
                justify-content: center;
            }

            .white-space .wrapper {
                width: 245px;
                height: 270px;
            }

            .white-space .wrapper iron-icon {
                width: 200px;
                height: 100%;
                position: relative;
                left: 42px;
            }

            .white-space .wrapper .text {
                font-weight: 300;
                text-align: center;
                color: var(--gray-saturated-color);
            }

            .white-space .wrapper .text a {
                color: var(--blue-darkest-color);
            }

            .author {
                font-size: 12px;
                max-width: 200px;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
                margin-right: 10px;
            }

            .show-more {
                margin-left: 25px;
                cursor: pointer;
                text-decoration: underline;
            }

            plastic-custom-scroll {
                --plastic-custom-scroll-content-mixin:{
                    max-height: calc(100vh - 220px);
                };
            }

            .break-line {
                height: 30px;
                width: 1px;
                background: var(--gray-color);
                margin: 0 5px 0 22px;
                display: inline-block;
            }


            /** Sortable **/

            .list li.sortable-chosen {
                background: var(--gray-lightern-color);
            }

            .list li.sortable-ghost {
               opacity: 0;
            }

            .move {
                cursor: move;
                margin: 0 10px;
            }

            @media (min-width: 320px) and (max-width: 768px) {
                .hidden-xs {
                    display: none;
                }

                .hidden-lg {
                    display: block;
                }

                .add-task-wrapper {
                    padding: 5px 0 0 20px;
                }

                .add-task-wrapper input {
                    font-size: 18px;
                }

                .desktop-filters .row:first-child {
                    margin-left: 20px;
                }
                .list {
                    padding-left: 3px;
                }

                plastic-custom-scroll {
                    --plastic-custom-scroll-content-mixin:{
                        max-height: calc(100vh - 230px);
                    };
                }
                .list {
                    padding-right: 10px;
                }
            }

        </style>
        <!-- Filters -->
        <div id="filter" class="desktop-filters filters" hidden$="[[!tasks.length]]">
            <template is="dom-repeat" items="[[filters]]" as="filter">
                <div class$="row [[filter.type]] [[_computeSelectedFilterClass(filter,selectedFilter)]]" on-click="selectFilter">
                    <iron-icon class="filter-icon" icon="[[computeFilterIcon(filter.type)]]"></iron-icon>
                    <span><i18-n msgid="[[filter.text]]">[[filter.text]]</i18-n></span>
                </div>
            </template>
            <div class="break-line"></div>
            <div class$="row [[_computeSelectedMineClass(mineFilterSelected)]]" on-click="toggleMine">
                <iron-icon class="filter-icon" icon="designmap-task-manager:my"></iron-icon>
                <span><i18-n msgid="mine">mine</i18-n></span>
                <paper-checkbox class="mine-checkbox" on-change="toggleMine" checked="[[mineFilterSelected]]"></paper-checkbox>
            </div>
        </div>

        <!-- Hint -->
        <designmap-hint id="taskListHint"
                        previous
                        have-skip
                        name="taskList"
                        tri-left
                        vertical-offset="10"
                        horizontal-offset="340">
            <div class="title">
                <i18-n msgid="Task list">Task list</i18-n>
            </div>
            <div class="desc">
                <i18-n msgid="taskListDesc">taskListDesc</i18-n>
            </div>
        </designmap-hint>
        <!-- Hint -->

        <plastic-custom-scroll hidden$="[[!tasks.length]]" no-scroll="[[noScroll]]" id="scroller" fit small-bar>
            <ul class="list" id="list">
                <!-- filter="[[taskFilter(selectedFilter,limit,mineFilterSelected,tasks.*)]]" -->
                <sortable-js id="sortable" disabled="[[_sortableDisabled(MQ)]]" scroll-fn="[[scrollFn]]" store="[[store]]"  on-update="sortableUpdate" >
                    <template id="listRepeater" is="dom-repeat" items="[[tasks]]" filter="[[listFilter(selectedFilter,limit,mineFilterSelected,tasks.*)]]"  on-dom-change="listRepeaterDomChanged" as="task">
                        <li class$="[[computeItemClass(task,selected,selectedTasks)]]" data-id$="[[task._id]]" data-task-id$="[[task._id]]">
                            <!--<div class="line" class$="[[computeSubLineClass(task)]]"></div>-->
                            <designmap-circle-button id$="statusButton[[index]]" class="status-button ignore"
                                                     on-tap="changeStatus">
                                <iron-icon class="status-icon" icon="[[computeIcon(task.status,task.expired)]]"></iron-icon>
                            </designmap-circle-button>
                            <paper-tooltip for$="statusButton[[index]]" position="right">
                                <i18-n msgid="Change status">Change status</i18-n>
                            </paper-tooltip>
                            <div class="title ignore" title="[[task.name]]" on-click="select">[[task.name]]</div>
                            <div class="label no-selected ignore" hidden$="[[!_getLabel(task,labels)]]" style$="[[_getLabelStyle(task,labels)]]">[[_getLabelText(task,labels)]]</div>
                            <!--<div class="position no-selected">
                                [[task.position]]
                            </div>-->
                            <template is="dom-if" if="[[task.assignee]]">
                                <div class="assignee no-selected ignore">
                                    <designmap-avatar-projector user="[[_computeOwner(task.assignee)]]"></designmap-avatar-projector>
                                </div>
                            </template>
                            <template is="dom-if" if="[[_isThereExp(task.expired,task.status)]]">
                                <div class="expired_row no-selected ignore">[[computeTimeLeftFormMobile(task,language)]]</div>
                            </template>
                            <div class="move" id$="move[[index]]">
                                <iron-icon icon="editor:drag-handle"></iron-icon>
                            </div>
                            <!--<div id$="subtask[[index]]" class="subtask hidden-xs no-selected" on-tap="selectWithFocus">
                                <iron-icon icon="designmap-taskmanager:subtask"></iron-icon>
                                <div class$="subtask-count [[_subtskCls(task,tasks)]]">[[findSubtasksLength(task,tasks)]]</div>
                            </div>
                            <paper-tooltip for$="subtask[[index]]" position="left">
                                <i18-n msgid="Subtask count">Subtask count</i18-n>
                            </paper-tooltip>-->
                            <!--<div class="status-line"></div>-->
                        </li>
                    </template>
                </sortable-js>
                <div class="not-found-msg" hidden$="[[!showEmptyMsg]]">
                    <i18-n msgid="There are no found elements">There are no found elements</i18-n>
                </div>
            </ul>
            <!--<div hidden$="[[!_showMoreState(tasks,limit,selectedFilter)]]" class="show-more" on-click="showMore">
                <i18-n msgid="see more">see more</i18-n>
            </div>-->
        </plastic-custom-scroll>
        <template is="dom-if" if="[[!cannotAdd]]">
            <div class="add-task">
                <div class="add-task-wrapper">
                    <iron-a11y-keys id="a11yEditor" keys="enter" on-keys-pressed="addTask"></iron-a11y-keys>
                   <!-- <iron-a11y-keys id="a11yEditor" keys="backspace" on-keys-pressed="removeLastTask"></iron-a11y-keys>-->
                    <input is="iron-input" placeholder="[[translate(placeholder,language,i18Loaded)]]"
                           on-focus="addTaskFocus" on-blur="addTask"
                           value="{{taskName::keyup}}" auto-validate pattern="[\w\dа-яА-ЯёЁ ]+"
                           error-message="{{translate('TaskNameError',language,i18nLoaded)}}" id="addTask"/>
                </div>
            </div>
        </template>
        <template is="dom-if" if="[[_notFound(tasks.length,searchMode)]]">
            <div class="white-space">
                <div class="wrapper">
                    <div class="text">
                        <i18-n msgid="There is not found elements...">There is not found elements...</i18-n>
                        <a href="#" on-click="cancelSearch">
                            <i18-n msgid="Cancel search">Cancel search</i18-n>
                        </a>
                    </div>
                </div>
            </div>
        </template>
        <div on-mousedown="_lineMouseDown"  class$="[[computeLineClass(selected,dragLine)]]"></div>

        <!-- Associated components -->
        <designmap-hidden-panel target="[[bodyNode]]" position="top"
                                cancel-auto-closing
                                opened="[[computeHiddenPanelState(selectedTasks.length)]]">
            <div class="select-panel-content centred">
                <designmap-circle-button class="cancel-selecting" on-click="clearSelectedTasks">
                    <iron-icon icon="designmap:add" style="transform: rotate(45deg)"></iron-icon>
                </designmap-circle-button>
                <div class="selected">
                    [[selectedTasks.length]]
                    <i18-n msgid="selected">selected</i18-n>
                </div>
                <div class="button-set">
                    <button is="designmap-button" class="no-unselect" on-click="moveSelectedTasks" thin>
                        <i18-n msgid="Move">Move</i18-n>
                    </button>
                    <button is="designmap-button" class="no-unselect" on-click="archiveSelectedTasks" thin>
                        <i18-n msgid="Archive action">Archive</i18-n>
                    </button>
                </div>
            </div>
        </designmap-hidden-panel>

    </template>
    <script>
        var STATUSES = ['incomplete', 'in_progress', 'completed'];
        Polymer({
            is: 'designmap-task-list',
            behaviors: [
                ReduxBehavior,
                Polymer.IronResizableBehavior,
                Polymer.DesignMapMessagesBehavior,
                Polymer.DesignMapUtilsBehavior,
                Polymer.DesignMapHintService,
                Polymer.DesignMapTaskService,
                Polymer.DesignMapFsService,
                Polymer.DesignMapTaskNotifyService,
                Polymer.CombineActions(Polymer.TasksActions)
            ],
            numbersRegexp: /^\d*$/,
            properties: {
                /**
                 * If user cannot add task\subtask
                 * into list
                 */
                cannotAdd: {
                    type: Boolean,
                    value: false
                },
                /**
                 * Is there necessity to highlight selected
                 * element?
                 */
                selecting: {
                    type: Boolean,
                    value: false
                },
                /**
                 * Parent of current task. (null for top level)
                 */
                parent: {
                    type: String,
                    observer: 'parentChanged',
                    value: null
                },

                assignee: {
                    type: String,
                    value: null
                },
                /**
                 * Tasks list
                 */
                tasks: {
                    type: Array,
                    statePath: function(state) {
                        return this._getTasks(state);
                    }
                },
                /**
                 * Currently selected filter
                 */
                selectedFilter: {
                    type: Object,
                    value: {type: 'not_completed', text: 'not_completed'}
                },
                /**
                 * Filter array to provide dinamic
                 * filters.
                 */
                filters: {
                    type: Array,
                    value: [
                        {type: 'all', text: 'all'},
                        {type: 'not_completed', text: 'not_completed'},
                       /* {type: 'expired', text: 'expired'}*/
                    ]
                },
                /**
                 * Currently selected task
                 */
                selected: {
                    type: Object,
                    notify: true,
                    value: {},
                    observer: '_selectedChanged'
                },
                /**
                 * Designmap user
                 */
                user: {
                    type: Object,
                    statePath: 'user'
                },
                projectUsers: {
                    type: Array,
                    statePath: 'projectUsers'
                },
                /**
                 * Designmap user language
                 */
                language: {
                    type: String,
                    computed: '_computeLanguage(user.system.language)'
                },
                /**
                 * i18nLoaded
                 */
                i18Loaded: {
                    type: Boolean,
                    statePath: 'i18Loaded'
                },
                /**
                 * Role
                 */
                role: {
                    type: Object,
                    statePath: 'role'
                },
                projectId: {
                    type: String,
                    statePath: 'projectId'
                },
                /**
                 * Project
                 */
                project: {
                    type: Object,
                    statePath: 'project'
                },
                /**
                 * Current name of the task
                 */
                taskName: {
                    type: String,
                    value: ''
                },
                placeholder: {
                    type: String,
                    value: 'Add task'
                },
                MQ: {
                    type: String,
                    statePath: 'MQ'
                },
                noScroll: {
                    type: Boolean,
                    value: false
                },
                canBeNull: {
                    type: Boolean,
                    value: false
                },
                labels: {
                    type: Array,
                    computed: '_computeLabels(project.settings.taskManager.labels)'
                },
                sortWay: {
                    type: String,
                    value: 'position'
                },
                searchMode: {
                    type: Boolean,
                    value: false
                },
                limit: {
                    type: Number,
                    value: 9
                },
                defaultLimit: {
                    type: Number,
                    value: 9
                },
                filter: {
                    type: Boolean,
                    value: false
                },
                dragLine: {
                    type: Boolean,
                    value: false
                },
                manager: {
                    type: Object,
                    value: {}
                },
                mineFilterSelected: {
                    type: Boolean,
                    value: false
                },
                showEmptyMsg: {
                    type: Boolean,
                    value: false
                },

                order: {
                    type: Array,
                    value: []
                },

                projectDataLoaded: {
                    type: Boolean,
                    statePath: 'projectDataLoaded'
                },

                selectedTasks: {
                    type: Array,
                    value: []
                },
                bodyNode: {
                    type: Object,
                    value: function () {
                        return document.body;
                    }
                }
            },
            ready: function () {
                if (/Firefox/.test(window.navigator.userAgent)) this.classList.add('firefox');
                this.changeTime = null;
                this.timer = null;
            },
            attached: function () {
                this.updateStyles();
                this.applyFilter();
            },

            getOrder: function(){
                const data = localStorage.getItem('synecto:order') ? JSON.parse(localStorage.getItem('synecto:order')) : {};
                if(!data[this.projectId]) return [];
                if(!data[this.projectId][this.parent]) return [];
                const orderString = data[this.projectId][this.parent];
                return orderString ? orderString.split('|') : [];
            },

            applySort: function(){
                const order = this.getOrder();
                if(!this.$.sortable.sortable) return;
                this.$.sortable.sortable.sort(order || []);
            },

            applyFilter: function(){
                const data = localStorage.getItem('synecto:filter') ? JSON.parse(localStorage.getItem('synecto:filter')) : {};
                if(!data[this.projectId]) return;
                if(!data[this.projectId][this.parent]) return;
                const filterData = data[this.projectId][this.parent];
                this.selectedFilter = filterData;
            },

            _computeLabels: function (labels) {
                return labels || [];
            },
            /**
             * Compute icon.
             * @param type - status of task
             * @param expired - is task expired?
             * @returns {*}
             */
            computeIcon: function (type, expired) {
                var diff = moment.duration(moment(expired || moment()).diff(moment()));
                //if (diff._milliseconds < 0 && type != 'completed') return 'designmap-task-manager:expired';
                return 'designmap-task-manager:' + type;
            },
            computeFilterIcon: function (type) {
                return 'designmap-task-manager:' + type;
            },
            computeMsg: function (msg) {
                return this.translate(msg);
            },
            /**
             * Validate name of future task
             * @returns {boolean}
             */
            validate: function () {
                let found = null;
                if (/[\#\?\\\%\/\+\:]/.test(this.taskName)) return this.showErrorMessage('You cannot use special symbols in task name');
                if(this.findNotUniq(this.taskName)) return this.showErrorMessage('Name should be unique. Check archive too.');
                return !found;
            },
            openFilterSelector: function () {
                //if(this.MQ!='sm') return;
                this.$.filterSelector.open();
            },
            /**
             * Change selected task to affect
             * on task-details component
             * @param e
             */
            select: function (e) {
                if(!(e.metaKey || e.ctrlKey)) this.clearSelectedTasks();
                this.push('selectedTasks',e.model.task);
                this.fire('select-task', e.model.task);
            },
            clearSelectedTasks: function(){
                this.set('selectedTasks',[]);
                this.async(this.updateStyles,10);
            },
            /**
             * Change selected task to affect
             * on task-details component
             * @param e
             */
            selectWithFocus: function (e) {
                this.fire('select-task', e.model.task);
                this.async(function () {
                    this.fire('focus-input');
                });
            },
            /*   /!**
             *
             * @param length
             * @returns {boolean}
             *!/
             computeTasksMessage: function(length){
             return !!length;
             },*/
            /**
             * Compute special class related of task status
             * @param task - task
             * @returns {string}
             */
            computeItemClass: function (task,selected,selectedTasks) {
                var cls = this.isExpired(task.expired, task.status) ? 'expired' : task.status;
                if (!this.selected) return task.type;
                if(selectedTasks.length>1 && selectedTasks.indexOf(task)!=-1) return cls+= "item selector ";
                return (this.selected._id == task._id || this.isChildOf(this.selected._id, task._id) ? 'item ' + (this.selecting ? ' selected ' : ' ') + cls : 'item ' + cls) + ' ' + task.type
            },
            /**
             * Change task status
             * @param e
             */
            changeStatus: function (e) {
                if (!this.canUpdateTask(e.model.task)) return;
                // Tricky timer manipulation
                clearInterval(this.timer);
                var status = STATUSES[STATUSES.indexOf(e.model.task.status) + 1] || STATUSES[0];
                if(status=='completed' && this.checkDependencies(e.model.task)) return this.showErrorMessage('You cannot complete task until dependencies would be completed');
                const data = {status: status};
                if(status=='completed') data.completed = new Date();
                this.dispatch('updateTask', e.model.task._id, data);
                // Notify
                this.sendTaskStatusNotification(e.model.task);
            },

            completeTask: function (e) {
                if (!this.canChangeStatus(e.model.task)) return this.showErrorMessage('Only assignee can do it.');
                // Tricky timer manipulation
                clearInterval(this.timer);
                var status = 'completed';
                this.dispatch('_updateTask', e.model.task._id, {status: status});
                this.async(this.updateStyles);
                // Wait
                this.timer = setTimeout(function () {
                    this.dispatch('updateTask', e.model.task._id, {status: status});
                    // Notify
                    this.sendTaskStatusNotification(e.model.task);
                }.bind(this), 1000);
            },

            /**
             * Compute class of the line which placed
             * at right. It will depends on task status.
             * @param selected - selected task
             * @returns {string}
             */
            computeLineClass: function (selected,dragLine) {
//                var root = this.findRoot(selected);
//                if (!root) return '';
//                var cls = this.isExpired(root.expired, root.status) ? 'expired' : root.status;
                if (!selected) return 'line hide-on-mobile';
                var cls = this.isExpired(selected.expired, selected.status) ? 'expired' : selected.status;
                if(dragLine) cls+=' dragged'
                return 'line hide-on-mobile ' + cls;
            },
            /**
             * Compute class of the line which placed
             * at right. It will depends on task status.
             * @param selected - selected task
             * @returns {string}
             */
            computeSubLineClass: function (selected) {
                var cls = this.isExpired(selected.expired, selected.status) ? 'expired' : selected.status;
                return 'sub-line ' + (cls || '');
            },
            /**
             * Compute time left, and if time is gone we
             * have to set expired status.
             * @param expired - expired time ;
             * @returns {*}
             */
            computeTimeLeft: function (task) {
                if (task.status == 'completed') return this.translate('completed');
                var diff = moment.duration(moment(task.expired).diff(moment()));
                if (diff._milliseconds < 0) return this.translate('expired');
                return (diff.asDays() > 1 ? (Math.round(diff.asDays()) + ' ' + this.translate('days')) : Math.round(diff.asHours()) + ' ' + this.translate('hours')) + ' ' + this.translate('left');
            },
            /**
             * Compute time left, and if time is gone we
             * have to set expired status.
             * @param expired - expired time ;
             * @returns {*}
             */
            computeTimeLeftFormMobile: function (task) {
                if (task.status == 'completed') return this.translate('completed');
                if (!task.expired) return '';
                var diff = moment.duration(moment(task.expired).diff(moment()));
                if (diff._milliseconds < 0) return this.translate('expired');
                return (diff.asDays() > 1 ? (Math.ceil(diff.asDays()) + ' ' + this.translate('days').substr(0, 1)) : Math.ceil(diff.asHours()) + ' ' + this.translate('hours').substr(0, 1));
            },
            /**
             *
             * @param expired
             * @returns {boolean}
             */
            isExpired: function (expired, status) {
                if(!expired) return false;
                var diff = moment.duration(moment(expired).diff(moment()));
                return diff._milliseconds < 0 && status != 'completed';
            },
            /**
             * Before 1 do to experation
             */
            isExpiredSoon: function (expired, status, from, to) {
                if(!expired) return false;
                var diff = moment.duration(moment(expired).diff(moment()));
                const d = Math.ceil(diff.asDays());
                return  d > from && d <= to && status != 'completed';
            },
            /**
             * Open date picker
             * @param e
             */
            openDatePicker: function (e) {
                this.selected = e.model.task;
                this.async(function () {
                    document.querySelector('designmap-task-details').openDatePicker();
                })
            },
            /**
             * Filter state
             * @param filter
             * @returns {boolean}
             */
            computeFiltersState: function (filter) {
                return this.tasks && this.tasks.length && !filter;
            },
            /**
             * When parent changed we have to
             * change sub tasks.
             */
            parentChanged: function () {
                if (!this.parent && !this.canBeNull) return;
                this.applyFilter();
                this.tasks = this._getTasks(ReduxStore.getState());
            },
            /**
             * Get tasks
             */
            _getTasks: function(state){
                const tasks = state.tasks.filter(function (task) {
                    if(!task) return false;
                    return !task.removed && task.parent == this.parent;
                }.bind(this));
                return tasks;
            },
            /**
             * Compute filter classes
             * @param filter
             * @param selectedFilter
             * @returns {string}
             */
            computeFilterClass: function (filter, selectedFilter) {
                return filter.type + ' filter ' + (filter.type == selectedFilter ? 'selected' : '');
            },
            /**
             * Add task new task using field
             * placed at bottom of list.
             * @returns {*}
             */
            addTask: function () {
                this.fire('add-task-blur');
                // Validate
                this.$$('#addTask').validate();
                if (!this.taskName) return;
                if (!this.validate()) return ;
                // Check roles
                const parent = this.findTaskById(this.parent);
                const assignee = parent ? parent.assignee : null;
                const tuid = this.generateUid();
                var task = {
                    _id: tuid,
                    created: new Date(),
                    path: this.parent ? this.getPath(this.parent) : null,
                    name: this.taskName,
                    parent: this.parent,
                    owner: this.user._id,
                    status: 'incomplete',
                    removed: false,
                    removedBy:{user:null},
                    expired: null,
                    assignee: assignee
                };

                // Notify
                this.sendNewTaskNotification(task);
                // Scroll
                this.async(function(){this.$.scroller.setScroll(this.$.scroller.$.content.scrollHeight + 500)},10);
                this.async(function(){this.sortHook(tuid);});
                // Create task
                this.cannotAdd = true;
                this.dispatch('addTask', task).then(function (response) {
                    this.sortHook(response.task._id, tuid);
                    this.showUndoMessage('Task was added successfully.');
                    window.reachGoal('task_created','done');
                    this.$.scroller.calculate();
                    if (this.MQ != 'sm') this.$$('#addTask').focus();
                    //this.fire('select-task',response.task);
                    this.cannotAdd = false;
                    if(assignee) this.sendAssigneeNotification(response.task,assignee);
                }.bind(this)).catch(function(){
                    this.cannotAdd = false;
                    this.manageErrorResponse();
                }.bind(this));
                this.taskName = '';
            },

            sortHook: function(taskId, tuid){
                const order = this.getOrder();
                if(tuid) {
                    order.splice(order.indexOf(tuid),1);
                }
                order.push(taskId);
                this.saveSort(order);
                this.async(function(){this.applySort()});
            },


            addTaskFocus: function () {
                this.fire('add-task-focus');
            },

            /**
             * Select filter
             */
            selectFilter: function (e) {
                this.selectedFilter = e.model.filter;
                const filterStorage = JSON.parse(localStorage.getItem('synecto:filter')) || {};
                filterStorage[this.projectId] = filterStorage[this.projectId] || {};
                filterStorage[this.projectId][this.parent] = this.selectedFilter;
                localStorage.setItem('synecto:filter', JSON.stringify(filterStorage));
                this.async(this.updateStyles);
            },

            listFilter: function(selectedFilter, limit, mineFilterSelected){
                let i = 0;
                let okCount = 0;
                let order = this.getOrder() || [];
                return function (task) {
                    const ok = this.statusFilter(selectedFilter,task,mineFilterSelected);
                    ok ? i++ : null;
                    const indx = order.indexOf(task._id)!=-1 ? order.indexOf(task._id) : i;
                    //if(indx>limit) return false;
                    if(ok) okCount++;
                    this.showEmptyMsg = !okCount;
                    return ok;
                }.bind(this)
            },

            /**
             *
             * Task filter
             */
            taskFilter: function (selectedFilter, mineFilterSelected, limit) {
                let i = 0;
                return this.tasks ? this.tasks.filter(function (task) {
                        const ok = this.statusFilter(selectedFilter,task,mineFilterSelected);
                        ok ? i++ : null;
                        if(i>limit) return false;
                        return ok;
                    }.bind(this)) : [];
            },

            statusFilter: function(selectedFilter,task,mineFilterSelected){
                if (task.removed) return false;
                if (mineFilterSelected && this.user && task.assignee != this.user._id) return false;
                if (selectedFilter.type == 'not_completed') return task.status != 'completed';
                if (selectedFilter.type == 'all') return true;
                return selectedFilter.type == task.status;
            },

            /**
             * Task filter to define message displaying
             */
            checkTaskFilter: function (selectedFilter,mineFilterSelected,limit) {
                let i = 0;
                return this.tasks ? this.taskFilter(selectedFilter,mineFilterSelected,limit).length: true;
            },
            /**
             * Select new assignee to current task
             * @param e
             */
            selectAssignee: function (e) {
                if (!e.detail || !e.detail._id) return;
                this.task = e.detail.task;
                this.dispatch('updateTask', e.detail.task._id, {assignee: e.detail._id});
                // Notify but do not do this if for itseld
                if (e.detail._id == this.user._id) return;
                this.sendTaskAssigneeNotification(e.detail.task, e.detail._id);
            },

            removeAssignee: function (e) {
                if (!e.detail || !e.detail.task) return;
                this.dispatch('updateTask', e.detail.task._id, {assignee: null});
            },
            _selectedChanged: function () {
                this.async(this.updateStyles,10);
            },
            _computeSelectedFilterClass: function (filter, selectedFilter) {
                return filter.type == selectedFilter.type ? 'selected' : '';
            },
            _computeSelectedMineClass: function (selected) {
                return selected ? 'selected' : '';
            },
            skipTutorialStep: function () {
                this.doneHint('taskList', 'tm');
            },
            _getLabel: function(task,labels){
                if(!labels || !labels.find || !task) return false;
                const label = labels.find(function(label){
                    if(!label) return false;
                    return label.label == task.label;
                });
                return label;
            },
            _getLabelStyle: function (task,labels) {
                const label = this._getLabel(task,labels);
                if(!label) return '';
                return 'background:rgb('+label.color.red+','+label.color.green+','+label.color.blue+');';
            },

            _getLabelText: function (task,labels) {
                const label = this._getLabel(task,labels);
                if(!label) return 'xxx';
                return label.label;
            },

            search: function(filters) {
                const elements = ReduxStore.getState().tasks;
                // Drop filter
                this.selectedFilter = {type:'all',text:'all'};
                // Find tasks
                let filtred = elements.filter(function(element){
                    let fit = true;
                    Object.keys(filters).forEach(function(filterName){
                        const filter = filters[filterName];
                        switch(filter.type) {
                            case 'select':
                                if(filter.value=='all') return;
                                if(filter.value=='expired') return fit = this.isExpired(element.expired, element.status);
                                if(filter.value=='expired_tomorrow') return fit = this.isExpiredSoon(element.expired, element.status,0,1);
                                if(filter.value=='expired_week') return fit = this.isExpiredSoon(element.expired, element.status,0,7);
                                if(filter.value=='expired_month') return fit = this.isExpiredSoon(element.expired, element.status,0,31);
                                if(element[filterName]!=filter.value) fit = false;
                                break;
                            case 'search':
                                fit = false;
                                const searchHub = ['name','description'];
                                const searchRegexp = new RegExp('.*'+filter.value.toLowerCase()+'.*');
                                searchHub.forEach(function(prop){
                                    const text = element[prop].toLowerCase();
                                    if(searchRegexp.test(text)) fit = true;
                                });
                                if(!fit) {
                                    const taskId = this._computeTaskId(element);
                                    if(filter.value=='#'+taskId) fit=true;
                                }
                                break;
                        }
                    }.bind(this));
                    return fit;
                }.bind(this));
                //if(this._allData(filters)) filtred = filtred.slice(0,30);
                this.set('tasks',filtred);
            },

            _allData: function(filters){
                let count = 0;
                const filtersKeys = Object.keys(filters);
                filtersKeys.forEach(function(filterKey){
                    const filter = filters[filterKey];
                    if(filter.value=='all' || !filter.value) count++;
                });

                return filtersKeys.length==count;
            },


            _notFound: function(length,searchMode){
                return !length && searchMode;
            },

            _computeDraggable: function(searchMode,dragLine){
                return searchMode || dragLine?'false':'true';
            },

            _computeAuthorName: function(userId) {
                return this.computeOwnerName(this._computeOwner(userId));
            },

            _computeOwner: function(id) {
                const project = this.project;
                if(!project || !project.users) return;
                const users = project.users.concat([project.ownerData]);
                return users.find(function(user){
                    return user._id==id;
                });
            },

            cancelSearch: function(){
                this.fire('cancel-search');
            },

            _isThereExp: function(exp,status){
                return exp || status=='completed';
            },

            showMore: function(){
                this.limit = this.tasks.length + 1;
            },

            _showMoreState: function(tasks,limit,selectedFilter) {
                const tsks = tasks.filter(function(task){
                    return this.statusFilter(selectedFilter,task)
                }.bind(this))
                return tsks.length>limit;
            },

            _lineMouseDown: function(e){
                this.dragLine = true;
                document.addEventListener('mousemove', _drag);
                document.addEventListener('mouseup', _stop);
                let _this = this;
                _this.lastPageX = e.pageX;
                _this.bound = this.getBoundingClientRect();
                document.body.classList.add('non-select');
                function _drag(e) {
                    const delta = e.pageX - _this.lastPageX;
                    const newWidth = _this.bound.width + delta;
                    _this.async(function () {
                        this.fire('resize-col',newWidth);
                    });
                }

                function _stop(e) {
                    _this.dragLine = false;
                    document.body.classList.remove('non-select');
                    document.removeEventListener('mousemove', _drag);
                    document.removeEventListener('mouseup', _stop);
                }
            },

            toggleMine: function(){
                this.mineFilterSelected = !this.mineFilterSelected;
                this.async(this.updateStyles,10);
            },

            sortableUpdate: function (e) {
                // Prevent accidental click
               this.async(function(){
                   this.saveSort();
               },1000);
            },

            saveSort: function(newOrder){
                const order = newOrder ? newOrder : this.$.sortable.sortable.toArray().filter(function(itm){return itm.length>4;}.bind(this));
                const data = localStorage.getItem('synecto:order') ? JSON.parse(localStorage.getItem('synecto:order')) : {};
                data[this.projectId] = data[this.projectId] || {};
                data[this.projectId][this.parent] = order.join('|');
                localStorage.setItem('synecto:order',JSON.stringify(data));
            },

            listRepeaterDomChanged: function(){
                this.async(this.updateStyles,0);
                this.async(this.applySort.bind(this),0);
            },

            _sortableDisabled: function(MQ){
                return MQ=='sm';
            },

            computeHiddenPanelState: function (length) {
                return length > 1;
            },

            archiveSelectedTasks: function(){
                this.selectedTasks.forEach(function(task){
                    const id = task._id;
                    this.fire('reset');
                    this.async(function(){this.clearSelectedTasks();},0);
                    this.dispatch('$updateTask', id, {removed: true,removedBy:{user:this.user._id,date:new Date()}}).then(function (response) {
                        if (!response.success) return this.showErrorMessage('Cannot archive task');
                        this.fire('apply-sort-list');
                    }.bind(this));
                },this);
            },
            moveSelectedTasks: function(){
                this.fire('open-move-tasks-dialog',this.selectedTasks);
            }
        })
    </script>
</dom-module>
